<html><head><title>The Weighted Majority Algorithm</title></head><body><h1>The Weighted Majority Algorithm</h1><p><i>Eliezer Yudkowsky, 12 November 2008 11:19PM</i></p><div><p><strong>Followup to</strong>:  <a href="0543.html">Worse Than Random</a> [http://lesswrong.com/lw/vp/worse_than_random/], <a href="0240.html">Trust In Bayes</a> [http://lesswrong.com/lw/na/trust_in_bayes/]</p> <p>In the wider field of Artificial Intelligence, it is not <em>universally</em> agreed and acknowledged that noise hath no power.  Indeed, the conventional view in machine learning is that randomized algorithms sometimes perform better than unrandomized counterparts <em>and there is nothing peculiar about this.</em>  Thus, reading an ordinary paper in the AI literature, you may suddenly run across a remark:  "There is also an improved version of this algorithm, which takes advantage of randomization..."</p> <p>Now for myself I will be instantly suspicious; I shall inspect the math for reasons why <a href="0543.html">the unrandomized algorithm is being somewhere stupid</a> [http://lesswrong.com/lw/vp/worse_than_random/], or why the randomized algorithm has a hidden disadvantage.  I will look for something peculiar enough to explain the peculiar circumstance of a randomized algorithm somehow doing <em>better.</em></p> <p>I am not completely alone in this view.  E. T. Jaynes, I found, was of the same mind:  "It appears to be a quite general principle that, whenever there is a randomized way of doing something, then there is a nonrandomized way that delivers better performance but requires more thought."  Apparently there's now a small cottage industry in derandomizing algorithms.  But so far as I know, it is not yet the majority, mainstream view that "we can improve this algorithm by randomizing it" is an extremely suspicious thing to say.</p> <p>Let us now consider a specific example - a mainstream AI algorithm where there is, apparently, a mathematical proof that the randomized version performs better.  By showing how subtle the gotcha can be, I hope to convince you that, even if you run across a case where the randomized algorithm is widely believed to perform better, and you can't find the gotcha yourself, you should nonetheless <a href="0240.html">trust that there's a gotcha to be found</a> [http://lesswrong.com/lw/na/trust_in_bayes/].</p> <p><a id="more"></a></p> <p>For our particular example we shall examine the weighted majority algorithm, first introduced by <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.37.1595">Littlestone and Warmuth</a> [http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.37.1595], but as a substantially more readable online reference I will use section 2 of Blum's <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.44.8097">On-Line Algorithms in Machine Learning</a> [http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.44.8097].  (Blum has an easier-to-read, more concrete version of the proofs; and the unrandomized and randomized algorithms are presented side-by-side rather than far part.)</p> <p>The weighted majority algorithm is an <em>ensemble method</em> - a way to combine the advice from several other algorithms or hypotheses, called "experts".  Experts strive to classify a set of environmental instances into "positive" and "negative" categories; each expert produces a prediction for each instance.  For example, each expert might look at a photo of a forest, and try to determine whether or not there is a camouflaged tank in the forest.  Expert predictions are binary, either "positive" or "negative", with no probability attached.  We do not assume that any of our experts is perfect, and we do not know which of our experts is the best.  We also do not assume anything about the samples (they may not be independent and identically distributed).</p> <p>The weighted majority algorithm initially assigns an equal weight of 1 to all experts.  On each round, we ask all the experts for their predictions, and sum up the weights for each of the two possible predictions, "positive" or "negative".  We output the prediction that has the higher weight.  Then, when we see the actual result, we multiply by 1/2 the weight of every expert that got the prediction wrong.</p> <p>Suppose the total number of experts is <tt>n</tt>, and the best expert makes no more than <tt>m</tt> mistakes over some given sampling sequence.  Then we can prove that the weighted majority algorithm makes a total number of mistakes <tt>M</tt> that is bounded by <tt>2.41*(m + log2(n))</tt>.  In other words, the weighted majority algorithm makes no more mistakes than the best expert, plus a factor of log <tt>n</tt>, times a constant factor of 2.41.</p> <p>Proof (taken from <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.44.8097">Blum 1996</a> [http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.44.8097]; a similar proof appears in <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.37.1595">Littlestone and Warmuth 1989</a> [http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.37.1595]):  The combined weight of all the experts at the start of the problem is <tt>W = n</tt>.  If the weighted majority algorithm makes a mistake, at least half the total weight of experts predicted incorrectly, so the total weight is reduced by a factor of at least 1/4.  Thus, after the weighted majority algorithm makes <tt>M</tt> mistakes, its total weight <tt>W</tt> has been reduced by at least <tt>(3/4)^M</tt>.  In other words:    </p> <blockquote> <p><tt>W &lt;= n*( (3/4)^M )</tt></p> </blockquote> <p>But if the best expert has made at most <tt>m</tt> mistakes, its weight is at least  (1/2)^m.  And since W includes the weight of all experts,    </p> <blockquote> <p><tt>W &gt;= (1/2)^m</tt></p> </blockquote> <p>Therefore:</p> <blockquote> <p><tt>(1/2)^m &lt;= W &lt;= n*( (3/4)^M )<br> (1/2)^m &lt;= n*( (3/4)^M )<br> -m  &#160;&#160;  &lt;= log2(n) + M*log2(3/4)<br> -m  &#160;&#160;  &lt;= log2(n) + M*-log2(4/3)<br> M*log2(4/3) &lt;= m + log2(n)<br> M  &#160;&#160;   &lt;= (1/log2(4/3))*(m + log2(n))<br> M  &#160;&#160;   &lt;= 2.41*(m + log2(n))</tt></p> </blockquote> <p>Blum then says that "we can achieve a better bound than that described above", by randomizing the algorithm to predict "positive" or "negative" with <em>probability</em> proportional to the weight assigned each prediction.  Thus, if 3/4 of the expert weight went to "positive", we would predict "positive" with probability 75%, and "negative" with probability 25%.</p> <p>An essentially similar proof, summing over the expected probability of a mistake on each round, will show that in this case:</p> <blockquote> <p><tt>M &lt;= 1.39m + 2 ln(n)  &#160;&#160;   </tt><em>(note: M is now an expectation)</em></p> </blockquote> <p>Since the penalty applied to particular experts does not depend on the <em>global prediction</em> but only on the <em>actual outcome,</em> most of the proof proceeds as before.  We have<tt></tt></p> <blockquote> <p><tt>W &gt;= (1/2)^m</tt></p> </blockquote> <p>where again <tt>m</tt> is the best expert and <tt>W</tt> is the total weight of all experts.</p> <p>We also have that W is the starting weight <tt>n</tt> times the product of <tt>(1 - 1/2 F_i)</tt>, where <tt>F_i</tt> is the fraction of mistaken expert weight on round i:</p> <blockquote> <p><tt>W = n * Prod_i (1 - 1/2 F_i)</tt></p> </blockquote> <p>And since we predict with probability proportional to the expert weight, the expected number of mistakes is just the sum over F_i:</p> <blockquote> <p><tt>M = Sum_i F_i</tt></p> </blockquote> <p>So:</p> <blockquote> <p><tt>(1/2)^m  &#160;&#160; &#160;&#160; &#160;&#160; &#160;&#160;   &lt;= </tt><tt>n * Prod_i (1 - 1/2 F_i)<br>-m*ln(2)  &#160;&#160; &#160;&#160; &#160;&#160; &#160;&#160;  &lt;= ln(n) + Sum_i ln(1 - 1/2 F_i)<br>Sum_i -ln(1 - 1/2 F_i) &lt;= ln(n) + m*ln(2)<br>Sum_i (1/2 F_i)  &#160;&#160; &#160;&#160; &lt;= ln(n) + m*ln(2)  &#160;&#160;  </tt><em>(because </em>x &lt; -ln(1 - x)<em> )</em><br><tt>Sum_i F_i  &#160;&#160; &#160;&#160; &#160;&#160; &#160;&#160; &lt;= 2*(ln(n) + m*ln(2))<br>M  &#160;&#160; &#160;&#160; &#160;&#160; &#160;&#160; &#160;&#160; &#160;&#160;   &lt;= 1.39m + 2 ln(n)</tt><tt></tt></p> </blockquote> <p>Behold, we have done better by randomizing!</p> <p>We should be <em>especially</em> suspicious that the randomized algorithm guesses with probability proportional to the expert weight assigned.  This seems strongly reminiscent of <a href="0542.html">betting with 70% probability on blue, when the environment is a random mix of 70% blue and 30% red cards</a> [http://lesswrong.com/lw/vo/lawful_uncertainty/].  We know the best bet - and yet we only <em>sometimes</em> make this best bet, at other times betting on a condition we believe to be <em>less</em> probable.</p> <p>Yet we thereby <em>prove</em> a smaller upper bound on the expected error.  Is there an algebraic error in the second proof?  Are we extracting useful work from a noise source?  Is our knowledge harming us so much that we can do better through ignorance?</p> <p>Maybe the unrandomized algorithm fails to take into account the Bayesian value of information, and hence fails to exhibit exploratory behavior?  Maybe it doesn't test unusual cases to see if they might have surprising results?</p> <p>But, examining the assumptions, we see that the feedback we receive is fixed, regardless of the prediction's output.  Nor does the updating of the expert weights depend on the predictions we output.  It doesn't matter whether we substitute a completely random string of 1s and 0s as our actual output.  We get back exactly the same data from the environment, and the weighted majority algorithm updates the expert weights in exactly the same way.  So that can't be the explanation.</p> <p>Are the component experts doing worse than random, so that by randomizing our predictions, we can creep back up toward maximum entropy?  But we didn't assume anything about how often the component experts were right, or use the fact in the proofs.  Therefore the proofs would carry even if we specified that all experts were right at least 60% of the time.  It's hard to see how randomizing our predictions could help, in that case - but the proofs still go through, unchanged.</p> <p>So where's the gotcha?</p> <p>Maybe I'm about to tell you that I looked, and I couldn't find the gotcha either.  What would you believe, in that case?  Would you think that the whole thesis on the futility of randomness was probably just wrong - a reasonable-sounding philosophical argument that simply wasn't correct in practice?  Would you despair of being able to follow the math, and give up and shrug, unable to decide who might be right?</p> <p>We don't <em>always</em> see the flaws right away, and that's something to always remember.</p> <p>In any case, I'm about to start explaining the gotcha.  If you want to go back, read the paper, and look yourself, you should stop reading now...</p> <p>There does exist a rare class of occasions where we want a source of "true" randomness, such as a quantum measurement device.  For example, you are playing rock-paper-scissors against an opponent who is <em>smarter than you are</em>, and who knows exactly how you will be making your choices.  In this condition it is wise to choose randomly, because any method your opponent can predict will do worse-than-average.  Assuming that the enemy knows your source code has strange consequences: the action sequence 1, 2, 1, 3 is good when derived from a quantum noise generator, but bad when derived from <em>any</em> deterministic algorithm, even though it is the same action sequence.  Still it is not a totally unrealistic situation.  In real life, it is, in fact, a bad idea to play rock-paper-scissors using an algorithm your opponent can predict.  So are we, in this situation, deriving optimization from noise?</p> <p>The random rock-paper-scissors player does not play cleverly, racking up lots of points.  It does not win more than 1/3 of the time, or lose less than 1/3 of the time (on average).  The randomized player does better because its alternatives perform poorly, not from being smart itself.  Moreover, by assumption, the opponent is an intelligence whom we <em>cannot</em> outsmart and who <em>always</em> knows everything about any method we use.  There is no move we can make that does not have a possible countermove.  By assumption, our own intelligence is entirely useless.  The best we can do is to avoid all regularity that the enemy can exploit.  In other words, we do best by <em>minimizing</em> the effectiveness of intelligence within the system-as-a-whole, because <em>only</em> the enemy's intelligence is allowed to be effective.  If we can't be clever ourselves, we might as well think of ourselves as the environment and the enemy as the sole intelligence within that environment.  By becoming the maximum-entropy environment for rock-paper-scissors, we render all intelligence useless, and do (by assumption) the best we can do.</p> <p>When the environment is adversarial, smarter than you are, and informed about your methods, then in a theoretical sense it may be wise to have a quantum noise source handy.  (In a practical sense you're just screwed.)  Again, this is not because we're <a href="0271.html">extracting useful work from a noise source</a> [http://lesswrong.com/lw/o5/the_second_law_of_thermodynamics_and_engines_of/]; it's because the most powerful intelligence in the system is adversarial, and we're minimizing the power that intelligence can exert in the system-as-a-whole.  We don't do better-than-average, we merely minimize the extent to which the adversarial intelligence produces an outcome that is worse-than-average (from our perspective).</p> <p>Similarly, cryptographers have a legitimate interest in strong randomness generators because cryptographers are trying to minimize the effectiveness of an intelligent adversary.  Certainly entropy can act as an antidote to intelligence.</p> <p>Now back to the weighted majority algorithm.  Blum (1996) remarks:</p> <blockquote> <p>"Intuitively, the advantage of the randomized approach is that it dilutes the worst case.  Previously, the worst case was that slightly more than half of the total weight predicted incorrectly, causing the algorithm to make a mistake and yet only reduce the total weight by 1/4.  Now there is roughly a 50/50 chance that the [randomized] algorithm will predict correctly in this case, and more generally, the probability that the algorithm makes a mistake is tied to the amount that the weight is reduced."</p> </blockquote> <p>From the start, we did our analysis for an <em>upper bound</em> on the number of mistakes made.  A global upper bound is no better than the worst individual case; thus, to set a global upper bound we must bound the worst individual case.  In the worst case, our environment behaves like an adversarial superintelligence.</p> <p>Indeed randomness can improve the worst-case scenario, if the worst-case environment is allowed to exploit "deterministic" moves but not "random" ones.  It is like an environment that can decide to produce a red card whenever you bet on blue - unless you make the <em>same</em> bet using a "random" number generator instead of your creative intelligence.</p> <p>Suppose we use a quantum measurement device to produce a string of random ones and zeroes; make two copies of this string; use one copy for the weighted majority algorithm's random number generator; and give another copy to an intelligent adversary who picks our samples.  In other words, we let the weighted majority algorithm make exactly the same randomized predictions, produced by exactly the same generator, but we also let the "worst case" environment know what these randomized predictions will be.  Then the improved upper bound of the randomized version is mathematically invalidated.</p> <p>This shows that the improved upper bound proven for the randomized algorithm did <em>not</em> come from the randomized algorithm making systematically better predictions - doing superior cognitive work, being more intelligent - but because we arbitrarily declared that an intelligent adversary could read our mind in one case but not the other.</p> <p>This is not just a minor quibble.  It leads to the testable prediction that on real-world problems, where the environment is usually <em>not</em> an adversarial telepath, the unrandomized weighted-majority algorithm should do better than the randomized version.  (Provided that some component experts outperform maximum entropy - are right more than 50% of the time on binary problems.)</p> <p>Analyzing the worst-case scenario is standard practice in computational learning theory, but it makes the math do strange things.  Moreover, the assumption of the worst case can be subtle; it is not always explicitly labeled.  Consider the upper bound for the unrandomized weighted-majority algorithm.  I did not use the term "worst case" - I merely wrote down some inequalities.  In fact, Blum (1996), when initially introducing this bound, does not at first use the phrase "worst case".  The proof's conclusion says only:</p> <blockquote> <p>"Theorem 1. The number of mistakes M made by the Weighted Majority algorithm described above is never more than 2.41(m+lg n), where m is the number of mistakes made by the best expert so far."</p> </blockquote> <p>Key word:  <em>Never.</em></p> <p>The worst-case assumption for the unrandomized algorithm was implicit in calculating the right-hand-side of the inequality by assuming that, on each mistake, the total weight went down by a factor of 1/4, and the total weight never decreased after any successful prediction.  This is the absolute worst possible performance the weighted-majority algorithm can give.</p> <p>The assumption implicit in those innocent-looking equations is that the environment <em>carefully maximizes the anguish of the predictor:</em>  The environment so cleverly chooses its data samples, that on each case where the weighted-majority algorithm is allowed to be successful, it shall receive not a single iota of useful feedback - not a single expert shall be wrong.  And the weighted-majority algorithm will be made to err on sensory cases that produce the minimum possible useful feedback, maliciously fine-tuned to the exact current weighting of experts.  We assume that the environment can predict every aspect of the predictor and exploit it - unless the predictor uses a "random" number generator which we arbitrarily declare to be unknowable to the adversary.</p> <p>What strange assumptions are buried in that innocent little inequality,</p> <blockquote> <p><tt>&lt;=</tt></p> </blockquote> <p>Moreover, the entire argument in favor of the randomized algorithm was theoretically suspect from the beginning, because it rested on non-transitive inequalities.  If I prove an upper bound on the errors of algorithm X, and then prove a smaller upper bound on the errors of algorithm Y, it does not <em>prove</em> that <em>in the real world</em> Y will perform better than X.  For example, I prove that X cannot do worse than 1000 errors, and that Y cannot do worse than 100 errors.  Is Y a better algorithm?  Not necessarily.  Tomorrow I could find an improved proof which shows that X cannot do worse than 90 errors.  And then in real life, both X and Y could make exactly 8 errors.</p> <blockquote> <p><tt>4 &lt;= 1,000,000,000<br> 9 &lt;= 10</tt></p> </blockquote> <p>But that doesn't mean that 4 &gt; 9.</p> <p>So the next time you see an author remark, "We can further improve this algorithm using randomization..." you may not know exactly where to find the oddity.  If you'd run across the above-referenced example (or any number of others in the machine-learning literature), you might not have known how to deconstruct the randomized weighted-majority algorithm.  If such a thing should happen to you, then I hope that I have given you grounds to suspect that an oddity exists <em>somewhere</em>, even if you cannot find it - just as you would suspect a machine that proposed to extract work from a heat bath, even if you couldn't keep track of all the gears and pipes.</p> <p><a href="0542.html">Nominull</a> [http://lesswrong.com/lw/vo/lawful_uncertainty/] put it very compactly when he said that, barring an environment which changes based on the form of your algorithm apa<span id="comment-138607900-content">rt from its output, "By adding randomness to your algorithm, you spread its behaviors out over a particular distribution, and there must be at least one point in that distribution whose expected value is at least as high as the average expected value of the distribution."</span></p> <p>As I remarked in <a href="0272.html">Perpetual Motion Beliefs</a> [http://lesswrong.com/lw/o6/perpetual_motion_beliefs/]:</p> <blockquote> <p>I once knew a fellow who was <em>convinced</em> that his system of wheels and gears would produce reactionless thrust, and he had an Excel spreadsheet that would prove this - which of course he couldn't show us because he was still developing the system.  In classical mechanics, violating Conservation of Momentum is <em>provably</em> impossible.  So any Excel spreadsheet calculated <em>according to the rules of classical mechanics</em> must <em>necessarily</em> show that no reactionless thrust exists - unless your machine is complicated enough that you have made a mistake in the calculations.</p> </blockquote> <p>If you ever find yourself <em>mathematically proving</em> that you can do better by randomizing, I suggest that you <a href="0240.html">suspect your calculations</a> [http://lesswrong.com/lw/na/trust_in_bayes/], or <a href="0535.html">suspect your interpretation of your assumptions</a> [http://lesswrong.com/lw/vh/complexity_and_intelligence/], before you celebrate your extraction of work from a heat bath.<span id="comment-138607900-content"> </span></p></div> <hr><p><i>Original with comments: </i><a href="http://lesswrong.com/lw/vq/the_weighted_majority_algorithm/">The Weighted Majority Algorithm</a></p></body></html>